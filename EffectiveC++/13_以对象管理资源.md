
首先明确资源的概念。

资源就是一旦你申请使用了 用完就要还给系统。

比如C++中最常见的就是堆内存资源。

每次new一个对象出来 就是向系统申请了一块堆内存资源。

这个内存是不会主动释放的 需要申请的人记得释放 不然就会出现内存泄漏。

比如说其他的一些资源。

如互斥锁 数据库连接 网络socket都属于资源。

我们在编写代码时常常会因为忘记释放资源而导致一些问题。

或者说代码正确的执行到释放语句比较困难。

比如说这个例子。

```C++
class A {

};


void f() {
    A *p = new A;

    // doSomething
    delete p;   
}
```

<img src="./images/13_01.png">

f函数内定义了一个A类型的指针p。

在delete p之前做了一些其他的事。

这个代码结构是清晰的 我们申请了资源并且记得释放掉了 很完美。

但是如果doSomething的部分return了  或者抛出异常。

那么delete p就没被执行 资源就没被释放 问题就产生了。

正确的做法的借用对象来管理资源。

```C++
class A {

};


void f() {
    std::auto_ptr<A> p(new A);
    // doSomething
}
```

<img src="./images/13_02.png">

auto_ptr 其实也是一个类。

类对象在离开了作用域的情况下是会被调用析构函数释放掉的。

所以我们把 new A 返回的指针交给auto_ptr对象进行管理。

auto_ptr模拟了普通指针的行为。

包括(解引用 dereference) (->运算) (bool运算)。

使我们使用智能指针就和使用原生的指针一样方便。

auto_ptr就是一种智能指针。

auto_ptr对象不仅拥有指针的行为还能自动释放资源。

通常在new一个对象时就会把资源交由相应的对象进行管理（初始化智能指针对象）。

这也就是C++中所谓的RAII(Resource Acquisition Is Initialization)了。

资源获取即初始化。

使用auto_ptr时需要注意一个点。

auto_ptr在使用结束之后被自动释放资源。

所以不要让多个auto_ptr对象管理同一份资源。

<img src="./images/13_03.png">

看第一个例子 智能指针对象正常访问到数据。

第二个例子 拷贝构造的方式创建了一个新的对象p2。

对象p自动把资源的使用权交给了p2。

所以p2能正常访问到数据 p已经无法访问数据 程序抛出异常。

auto_ptr not dereferenceable 直译过来就是auto_ptr不可解引用。

实际上这时p已经是一个空指针了。

好了 这就是本期的全部内容了。

想了解更多相关的知识请关注我吧。

