
什么时候会复制对象

在调用拷贝构造(copy constructor)和拷贝赋值操作符(copy assignment operator)时

会复制一个类对象

所谓复制对象也就是复制对象内的数据

比如说

```C++
class A {
private:
    int m_a;
public:
    A(int a = 0) : m_a(a) { }
    A(const A &rhs) {
        m_a = rhs.m_a;        
    }

    A& operator=(const A &rhs) {
        m_a = rhs.m_a;
        return *this;
    }
};

A a1(1);
A a2(a1);  // 调用拷贝构造函数
A a3;
a3 = a1;  // 调用拷贝复制操作符
```

<img src="./images/11_01.png">

这个例子中

图中标红的第一部分调用的是拷贝构造函数

第二部分是调用拷贝复制操作符

这两个拷贝函数都是在拷贝一个对象的数据

以下统称这两个函数称为复制函数

对于类A中没有自定义的对象其实可以不写这两个函数

我们以前其实也说过了

编译器会自动生成默认的函数

当你定义了之后编译器就不会再生成

<img src="./images/11_02.png">

当需求发生变化需要在类A中增加新的数据

增加了一个成员 m_b

但是复制函数却没有增加 m_b 部分的拷贝

这就造成一个问题

拷贝的不是很全

所以如果新增成员变量时记得别忘了修改复制函数

```C++
class A {
private:
    int m_a;
};

class B : public A {
private:
    int m_b;
public:
    B(int b = 0) : A(), m_b(b) {}
    B(const B& rhs) {
        m_b = rhs.m_b;
    }

    B& operator=(const B& rhs) {
        m_b = rhs.m_b;
        return *this;
    }
};

B b1(1);
B b2(b1);
B b3 = b1;
```
<img src="./images/11_03.png">

第二种情况发生在类继承的时候

看这段代码

类A中依旧包含一个成员 m_a

类B继承自类A并且类B中有自己的成员 m_b

当图中标红的第一部分被执行时会调用代码中B的构造函数

首先在初始化列表中显式调用父类的构造函数

对象B中父类的部分 m_a 被初始化为0

属于自己的部分 m_b 被初始化为 1

当第二部分被执行会调用类B的拷贝构造函数

但此时只拷贝了子类的成员并未拷贝父类的部分

所以debug时 b2 中 m_a 的值是随机值

第三部分执行也是同样的道理

正确的做法是显式调用父类的复制函数把父类的部分也拷贝了

<img src="./images/11_04.png">

图中调用父类复制函数的部分我已经用红框给标出来了

仔细体会一下

<img src="./images/11_05.png">

这一大段其实也可以不写

因为类中并没有指针类型的成员

不涉及到深拷贝浅拷贝的问题

完全用编译器为我们提供的默认复制函数就够用了

如果你还理解不了我这段话

建议你去翻看我以前发布的内容

其实写不写怎么写很自由

但你得明白为什么

清楚原理之后才能做到游刃有余


