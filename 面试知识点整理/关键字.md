

### extern

在C++程序中调用被C编译器编译后的函数，为什么要加 `extern "C"` ?

C++ 语言支持函数重载，C语言不支持，函数被C++编译后在库中的名字与C语言不通，函数签名不同，C++提供了C链接交换指定符号 `extern C` 解决名字匹配的问题。


### const

1. `const` 位于 `*`的左侧: 用来修饰指针所指向的变量，指针指向常量。

```cpp
// 指针不允许改变数据
int b = 500;
const int *a = &b;
*a = 600; // error 
```

```cpp
// 可以通过变量本身去修改
int b = 500;
const int *a = &b;
b = 600;
cout << *a << endl; // 600
```


2. `const` 位于 `*`的右侧: 用来修饰指针本身，指针是常量。

```cpp
// 指针本身是常量，定义时需要初始化
int b = 500;
//int * const a;  // error
int * const c = &b;  // error

*c = 600;  // 正常，允许改值
cout << *c << endl;
```

3. `const` 用在成员函数中, 位于 `function_name () const {}`

我们在定义类的成员函数中，常常有一些成员函数不改变类的数据成员。 也就是说这些函数的 `readonly function`，而有一些函数要修改类的数据成员的值。 如果在`readonly function`都加上`const`进行标识，无疑会提高程序的可读性。 其实还能提高程序的可靠性，已定义成`const`的成员函数，一旦企图改变数据成员的值，则编译器按错误处理。

```cpp
class A
{
public:
	A(int x) : a(x) {}
	int get() const { return a; }
	int get2() const { return a++; }  // ERROR read-only object
private:
	int a;
};

int main(int argc, char const *argv[])
{
	A obj(10);
	cout << obj.get() << endl;
	cout << obj.get2() << endl;
	return 0;
}
```

const 修饰之后，`readonly function` 也将只能调用 `readonly function`, 其实很好理解，如果`readonly function` 函数调用了其他函数，可能数据就会发生变化。

```cpp
class A
{
public:
	A(int x) : a(x) {}
	int get() const { get2(); return a; }  // 错误，不能调用非 readonly function
	int get2() const {}
private:
	int a;
};

int main(int argc, char const *argv[])
{
	A obj(10);
	int b = obj.get();
	cout << b << endl;
	return 0;
}
```

如果类的数据成员加上`mutable`后，修饰为 `const`的成员变量，也可以修改。

```cpp
class A
{
public:
	A(int x) : a(x) {}
	int get() const { return ++a; }
private:
	mutable int a;
};


int main(int argc, char const *argv[])
{
	A obj(10);
	int b = obj.get();
	cout << b << endl;
	return 0;
}
```

4. const 位于函数声明前，意味着函数的返回值是常量


### inline

**内联函数和宏有什么差别？**

内联函数和普通函数相比可以加快程序的运行速度，因为不需要中断调用，在编译的时候内联函数可以直接被镶嵌到目标代码中。而宏只是一个简单的替换。

宏是在代码处不加任何验证的简单替换，而内联函数是将代码直接插入调用处，而减少了普通函数调用时的资源消耗。

关键字inline必须与函数定义体放在一起才能使函数成为内联，仅将inline放在函数声明前面不起任何作用。

如下风格的函数Foo不能成为内联函数。

```cpp
inline void Foo(int x, int y);  // inline 仅与函数声明放在一起
void Foo(int x, int y);
```

而如下风格的函数Foo则成为内联函数：

```cpp
void Foo(int x, int y);
inline void Foo(int x, int y);  // inline 与函数定义放在一起
```






































