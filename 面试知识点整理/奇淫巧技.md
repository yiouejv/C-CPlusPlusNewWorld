

### 1. 用一个表达式，判断一个数x是否是2的n次方（2，4，8，16...）, 不可用循环语句。

2的n次方数转化为二进制，其中只有一位是1，可以借助 `x & (x - 1)` 去除最低位的1，如果结果为0说明只有一位是1。

`!(X & (X-1))`


### 2. 下面代码

```cpp
int f(int x, int y)
{
    return (x & y) + ((x ^ y) >> 1);
}
```

f(729, 271) = ________。

如果按照正常流程把int转换成二进制形式，进行按位与，按位异或，移位操作，显然不上面试官所期待的，仔细观察以下题目，`x&y`是取相同的位与，这个结果是x和y相同位的和的一半，`x^y`是取x 和 y的不同位，右移相当于除以 2，所以这个函数的功能是取两个数的一半。

(729+271) / 2 = 500

### 3. 利用位运算实现两个整数的加法运算。

```cpp
int f(int a, int b)
{
    if (b == 0) return a;  // 没有进位的时候完成运算
    int sum, crray;
    sum = a ^ b;  // 完成第一步没有进位的加法运算
    crray = (a & b) << 1;  // 完成第二步进位
    return f(sum, crray);  // 进行递归相加
}
```


### 4. 有两个数据，写一个数据交换的宏

正常情况下，大多数人想到的都是异或运算，但是如果待交换的数是浮点数时，则不能进行异或，正确的做法是内存交换。

```cpp
#define swapp(a, b) do { \
char buff[10]; \
memcpy(buff, &a, sizeof(a)); \
memcpy(&a, &b, sizeof(b)); \
memcpy(&b, buff, sizeof(a)); \
} while(0)
```

扩展: 宏的编写技巧

反斜线代表该行未结束，会串接下一行。而如果宏里有多过一个语句（statement），就需要用 do { /*...*/ } while(0) 包裹成单个语句，否则会有如下的问题：

```cpp
#define M() a(); b()
if (cond)
    M();
else
    c();

/* 预处理后 */

if (cond)
    a(); b(); /* b(); 在 if 之外     */
else          /* <- else 缺乏对应 if */
    c();
```

只用 { } 也不行：

```cpp
#define M() { a(); b(); }

/* 预处理后 */

if (cond)
    { a(); b(); }; /* 最后的分号代表 if 语句结束 */
else               /* else 缺乏对应 if */
    c();
```

用 do while 就行了：

```cpp
#define M() do { a(); b(); } while(0)

/* 预处理后 */

if (cond)
    do { a(); b(); } while(0);
else
    c();
```

