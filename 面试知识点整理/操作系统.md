

### 进程和线程的区别

### 进程控制块

主要包括用于描述和控制进程运行的信息，分别是进程标识符信息，处理机状态信息，进程调度信息，进程控制信息。

1.**程序ID（PID、进程句柄）**：它是唯一的，一个进程都必须对应一个PID。PID一般是整形数字   
2.**特征信息**：一般分系统进程、用户进程、或者内核进程等   
3.**进程状态**：运行、就绪、阻塞，表示进程现的运行情况   
4.**优先级**：表示获得CPU控制权的优先级大小   
5.**通信信息**：进程之间的通信关系的反映   
6.**现场保护区**：保护阻塞的进程用   
7.**资源需求、分配控制信息**  
8.**进程实体信息**: 指明程序路径和名称，进程数据在物理内存还是在交换分区（分页）中   
9.**其他信息**：工作单位，工作区，文件信息等   

### fork, exec 的区别

`fork`

一个程序一调用fork函数，系统就为一个新的进程准备了前述三个段，首先，系统让新的进程与旧的进程使用同一个代码段，因为它们的程序还是相同的，对于数据段和堆栈段，系统则复制一份给新的进程，这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。而如果两个进程要共享什么数据的话，就要使用另一套函数（shmget，shmat，shmdt等）来操作。现在，已经是两个进程了，对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零，这样，对于程序，只要判断fork函数的返回值，就知道自己是处于父进程还是子进程中。事实上，目前大多数的unix系统在实现上并没有作真正的copy。一般的，CPU都是以“页”为单位分配空间的，象INTEL的CPU，其一页在通常情况下是4K字节大小，而无论是数据段还是堆栈段都是由许多“页”构成的，fork函数复制这两个段，只是“逻辑”上的，并非“物理”上的，也就是说，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的“页”从物理上也分开。系统在空间上的开销就可以达到最小。


**提炼**

- 子进程和父进程使用同一个代码段，数据段和堆栈段则是复制一份父进程的。 这种复制是逻辑上的，只有当有一个进程修改数据时，才会真正复制。
- fork函数，父进程返回子进程的pid，子进程返回0


`exec`

一个进程一旦调用exec类函数，它本身就“死亡”了，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。不过exec类函数中有的还允许继承环境变量之类的信息，这个通过exec系列函数中的一部分函数的参数可以得到。

**提炼**

- 老进程代码段替换成新进程代码段，放弃原来的数据段和堆栈段，为新进程重新分配。
- 进程号不变，对系统而言还是同一个进程。
- 新进程还可以继承环境变量等信息。


### 32位机器，Linux操作系统内存管理以“页”为基本单位，每页的大小固定为4KB

### 虚拟内存, swap 空间

windows：虚拟内存

linux：swap分区

windows即使物理内存没有用完也会去用到虚拟内存，而Linux不一样 Linux只有当物理内存用完的时候才会去动用虚拟内存（即swap分区）

swap类似于windows的虚拟内存，不同之处在于，Windows可以设置在windows的任何盘符下面，默认是在C盘，可以和系统文件放在一个分区里。而linux则是独立占用一个分区，方便由于内存需求不够的情况下，把一部分内容放在swap分区里，待内存有空余的情况下再继续执行，也称之为交换分区，交换空间是其中的部分

windows的虚拟内存是电脑自动设置的

Linux的swap分区是你装系统的时候分好的

### 页表表项中的访问位由cpu置位，存在位由操作系统值位

### read打开文件的过程

read 系统调用通过陷入将CPU从用户态切换到核心态，从而获取操作系统提供的服务，要读取一个文件首先要用open系统调用打开该文件，open中的参数包含文件的路径名和文件名，而read只需要使用open返回的文件描述符，并不使用文件名作为参数，read要求用户提供三个输入参数，文件描述符，buf缓冲区首地址，传送的字节数，read的功能是试图从fd所指示的文件中读入n个字节的数据，并将他们送至由buf指针指向的缓冲区中。

